<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.js"></script>
    <script src="function.js"></script>
    <script src="load.js"></script>
    <script src="generator.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding-top: 50px; /* Pour éviter que le contenu se cache derrière la barre supérieure */
            overflow: hidden; /* Pour éviter les barres de défilement */
        }

        .top-bar {
            height: 2.5vh;
            width: 100%;
            background: #333;
            padding: 10px;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 100;
            display: flex;
            justify-content: space-between;
        }

        .top-bar div {
            flex: 1;
            text-align: center;
            font-size: 1.5vh;
        }

        .top-bar button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
        }

        .top-bar button:hover {
            background: #45a049;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 9999;  /* augmenter la valeur de z-index */
            padding-top: 100px;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }

        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 20px;
            border: 1px solid #888;
            width: 50%;
            text-align: center;
            border-radius: 5px;
            z-index: 1;
        }

        .modal-content h2 {
            color: #333;
        }

        .modal-content button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
        }

        .modal-content button:hover {
            background: #45a049;
        }

        .minimap {
            position: fixed;
            left: 0;
            bottom: 0;
            z-index: 101;
            border: 3px solid #000000;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div class="top-bar">
        <div class="top-bar">
            <div>
                <button id="pause">Pause</button>
            </div>
            <div>
                <span id="gold">Gold: 0</span>
            </div>
            <div>
                <span id="mana">Mana: 0</span>
            </div>
            <div>
                <span id="units">Units: 0/100</span>
            </div>
            <div>
                <span id="game-time">Time: 00:00</span>
            </div>
            <div>
                <button id="settings">Paramètres</button>
            </div>
        </div>
    </div>
    <div class="minimap">
        <canvas id="minimap" width="250" height="250" ></canvas>
    </div>

    <div id="modal" class="modal">
        <div class="modal-content">
            <h2>Paramètres</h2>
            <label for="volume">Volume</label>
            <input type="range" id="volume" name="volume" min="0" max="100">
            <button id="continue">Continuer</button>
            <button id="quit">Quitter</button>
        </div>
    </div>

    <script>
        let paused = false;
        let gold = 0;
        let mana = 0;
        let units = 0;
        const maxUnits = 100;
        let gameTime = '00:00';

        document.getElementById('pause').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pause').innerText = paused ? 'Play' : 'Pause';
        });

        document.getElementById('settings').addEventListener('click', () => {
            document.getElementById('modal').style.display = 'block';
        });

        document.getElementById('continue').addEventListener('click', () => {
            document.getElementById('modal').style.display = 'none';
        });

        document.getElementById('quit').addEventListener('click', () => {
            if (confirm('Êtes-vous sûr de vouloir quitter ?')) {
                window.location.href = 'accueil.html'; // Remplacer par l'URL de votre page d'accueil
            }
        });

        const indicators = {
          "CO2" : "EN.ATM.CO2E.KT", // En kilotonnes | Influe sur le pourcentage de zone morte
          "PIB" : "NY.GDP.MKTP.CD", // En dollars | Influe sur le revenu des mines
          "Population" : "SP.POP.TOTL", // | Influe sur le nombre d'ennemis
          "Territoire" : "AG.LND.TOTL.K2", // En km carrés | Influe sur la taille de la carte
          "SurfaceForestiere" : "AG.LND.FRST.ZS", // En % | Influe sur le nombre d'arbre
          "Croissancepop" : "SP.POP.GROW", // En % | Influe sur la vitesse de reproduction des ennemis
          "EsperanceVie" : "SP.DYN.LE00.IN", // En années | Influe sur le nombre de vie des ennemis
          "PopulationUrbaine" : "SP.URB.TOTL.IN.ZS", // En % | Influe sur le nombre d'ennemis dans un regroupement
          "TotalReserves" : "FI.RES.TOTL.CD", // En dollars | Influe sur le nombre de mine et le nombre de ressource dans les mines
        }

  const countries = {
          "France" : "FRA",
          "Etats-Unis" : "USA",
          "Chine" : "CHN",
          "Canada" : "CAN",
          "Bresil" : "BRA",
          "Argentine" : "ARG",
          "Suede" : "SWE",
          "Russie" : "RUS",
          "Turquie" : "TUR",
          "Japon" : "JPN",
          "Algerie" : "DZA",
          "Congo" : "COG",
          "Egypte" : "EGY",
          "AfriqueDuSud" : "ZAF",
          "Inde" : "IND",
          "Australie" : "AUS",
          "ArabieSaoudite" : "SAU",
          "Iran" : "IRN"
        }

    const etendueIndicator = {
        "CO2": {
            "min": 7260.00022888184,
            "max": 10707219.7265625
        },
        "PIB": {
            "min": 13366230219.5352,
            "max": 23315080560000
        },
        "Population": {
            "min": 5835806,
            "max": 1412360000
        },
        "Territoire": {
            "min": 341500,
            "max": 16376870
        },
        "SurfaceForestiere": {
            "min": 0.0451855944547692,
            "max": 68.6990703076107
        },
        "Croissancepop": {
            "min": -0.459952415807642,
            "max": 2.31648825280279
        },
        "EsperanceVie": {
            "min": 63.785,
            "max": 84.6156097560976
        },
        "PopulationUrbaine": {
            "min": 35.393,
            "max": 92.229
        },
        "TotalReserves": {
            "min": 988316008.036768,
            "max": 3427931394628.85
        }
    };

    const urlParams = new URLSearchParams(window.location.search);
    let countryIndicators = urlParams.get('indicators');
    
    if (!countryIndicators) {
        window.location.href = '../Helicoptere/helicoV3/helicoptere.html';
    } else {
        // Convertir les indicateurs en objet JavaScript
        countryIndicators = JSON.parse(countryIndicators);
    }

        // Initialize the map generator with the given parameters
        let mapGenerator = new MapGenerator(250, 250, countryIndicators, etendueIndicator);
        
        // Generate the map
        mapGenerator.generate();
        
        const map = mapGenerator.exportMap();
        
        let mapLoader = new Load(map.unitsElementsMatrix, map.lifeDeadZonesMatrix, map.spawnPoints, map.width, map.totems)
        mapLoader.load();
        


        let minimap = document.getElementById('minimap');
        let matrixSize = 250;  // Taille de la matrice
        let minimapSize = 250; // Taille de la minimap en pixels
        let ctx = minimap.getContext('2d');


        for (let i = 0; i < matrixSize; i++) {
            for (let j = 0; j < matrixSize; j++) {
                let x = i / matrixSize * minimapSize;
                let y = j / matrixSize * minimapSize;
                let pixelSize = minimapSize / matrixSize;

                switch (mapLoader.unitElement[j][i]) {
                    case -1:
                        ctx.fillStyle = "blue";
                        break;
                    case 1:
                        ctx.fillStyle = 'green';
                        break;
                    default:
                    ctx.fillStyle = '#4A2C0B';
                        break;
                }

                ctx.fillRect(x, y, pixelSize, pixelSize);
            }
        }

        for (let i = 0; i < matrixSize; i++) {
            for (let j = 0; j < matrixSize; j++) {
                let x = i / matrixSize * minimapSize;
                let y = j / matrixSize * minimapSize;
                let pixelSize = minimapSize / matrixSize;

                if(mapLoader.unitElement[j][i] == 101 && mapLoader.unitElement[j-1][i] != 101 && mapLoader.unitElement[j][i-1] != 101) {
                    let circleRadius = 5 * pixelSize; // Taille du rayon en pixels
                    ctx.beginPath();
                    ctx.arc(x + pixelSize / 2, y + pixelSize / 2, circleRadius, 0, 2 * Math.PI, false);
                    // IL faut vérifier si le totem est en vie ou pas pour changer la couleur
                    if(Math.random() < 0.5) {
                        ctx.fillStyle = 'red';
                    } else {
                        ctx.fillStyle = 'black';
                    }
                    ctx.fill();
                }

                if (mapLoader.unitElement[j][i] >= 500 && mapLoader.unitElement[j][i] < 600) {
                    let squareSize = 5 * pixelSize; // Taille du carré en pixels
                    ctx.fillStyle = 'white';
                    ctx.fillRect(x, y, squareSize, squareSize);
                }

            }
        }

        minimap.addEventListener('click', function(event) {
            let rect = minimap.getBoundingClientRect();
            let x = event.clientX - rect.left;
            let y = event.clientY - rect.top;

            // Convertir les coordonnées du pixel de la minimap en coordonnées de la matrice
            let matrixX = Math.floor(x / minimapSize * matrixSize);
            let matrixY = Math.floor(y / minimapSize * matrixSize);

            console.log('Matrix coordinates: (' + matrixX + ', ' + matrixY + ')');
        });

        drawMap(mapLoader.unitElement,20).then(() => {
            const cellSize = 20;
            const visionSize = 10;
            let cameraPosition = {
                x: matrixSize / 2,
                y: matrixSize / 2
            };

            let canvas = document.createElement('canvas');
            const ctxMap = canvas.getContext('2d');

            function updateView() {
                ctxMap.clearRect(0, 0, canvas.width, canvas.height);

                let startX = Math.floor(cameraPosition.x) - visionSize / 2;
                let startY = Math.floor(cameraPosition.y) - visionSize / 2;

                for(let i = 0; i < visionSize; i++) {
                    for(let j = 0; j < visionSize; j++) {
                        // Ici, vous devriez avoir une logique pour dessiner votre matrice basée sur i + startX et j + startY.
                        // Ceci est juste un exemple de dessin d'un carré gris.
                        ctxMap.fillStyle = 'gray';
                        ctxMap.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
                    }
                }
            }

            // Mise à jour de la position de la caméra
            function updateCamera(dx, dy) {
                cameraPosition.x += dx;
                cameraPosition.y += dy;
                cameraPosition.x = Math.max(Math.min(cameraPosition.x, matrixSize - visionSize / 2), visionSize / 2);
                cameraPosition.y = Math.max(Math.min(cameraPosition.y, matrixSize - visionSize / 2), visionSize / 2);
                updateView();
            }

            // Ecoute des événements de touche
            window.addEventListener('keydown', function(event) {
                console.log(cameraPosition)
                switch(event.key) {
                    case 'ArrowUp':
                        updateCamera(0, -1);
                        break;
                    case 'ArrowDown':
                        updateCamera(0, 1);
                        break;
                    case 'ArrowLeft':
                        updateCamera(-1, 0);
                        break;
                    case 'ArrowRight':
                        updateCamera(1, 0);
                        break;
                }
            }, false);

            // Mise à jour initiale
            updateView();
        });


        /*
        drawMap(mapLoader.unitElement,20).then(() => {
            let matrixSize = 250; // Taille de la matrice
            let cellSize = 20;
            let canvasWidth = 200; // Largeur du canvas en pixels
            let canvasHeight = 500; // Hauteur du canvas en pixels

            let targetX = 0; // Coordonnée X du point à centrer
            let targetY = 0; // Coordonnée Y du point à centrer

            // Calcul du décalage pour centrer le point
            let offsetX = 0;
            let offsetY = 0;
            console.log(offsetX, offsetY);

            let canvas = document.getElementById('mapCanvas');

            let ctx = canvas.getContext("2d");

            ctx.translate(offsetX, offsetY);

            const mapContainer = document.getElementById("map");
            mapContainer.innerHTML = "";
            mapContainer.appendChild(canvas);

        });*/
        
    </script>

</body>
</html>

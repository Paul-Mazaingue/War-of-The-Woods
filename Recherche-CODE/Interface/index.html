<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link type="text/css" media="screen" rel="stylesheet" href="css/style.css" />
    <script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.js"></script>

    <script src="generator.js"></script>
    <script src="function.js"></script>
    <script src="load.js"></script>
    <script src="camera.js"></script>
</head>
<body>
  <div id="viewport"></div>
</body>

<script>

    
  const indicators = {
          "CO2" : "EN.ATM.CO2E.KT", // En kilotonnes | Influe sur le pourcentage de zone morte
          "PIB" : "NY.GDP.MKTP.CD", // En dollars | Influe sur le revenu des mines
          "Population" : "SP.POP.TOTL", // | Influe sur le nombre d'ennemis
          "Territoire" : "AG.LND.TOTL.K2", // En km carrés | Influe sur la taille de la carte
          "SurfaceForestiere" : "AG.LND.FRST.ZS", // En % | Influe sur le nombre d'arbre
          "Croissancepop" : "SP.POP.GROW", // En % | Influe sur la vitesse de reproduction des ennemis
          "EsperanceVie" : "SP.DYN.LE00.IN", // En années | Influe sur le nombre de vie des ennemis
          "PopulationUrbaine" : "SP.URB.TOTL.IN.ZS", // En % | Influe sur le nombre d'ennemis dans un regroupement
          "TotalReserves" : "FI.RES.TOTL.CD", // En dollars | Influe sur le nombre de mine et le nombre de ressource dans les mines
        }

  const countries = {
          "France" : "FRA",
          "Etats-Unis" : "USA",
          "Chine" : "CHN",
          "Canada" : "CAN",
          "Bresil" : "BRA",
          "Argentine" : "ARG",
          "Suede" : "SWE",
          "Russie" : "RUS",
          "Turquie" : "TUR",
          "Japon" : "JPN",
          "Algerie" : "DZA",
          "Congo" : "COG",
          "Egypte" : "EGY",
          "AfriqueDuSud" : "ZAF",
          "Inde" : "IND",
          "Australie" : "AUS",
          "ArabieSaoudite" : "SAU",
          "Iran" : "IRN"
        }

    const etendueIndicator = {
        "CO2": {
            "min": 7260.00022888184,
            "max": 10707219.7265625
        },
        "PIB": {
            "min": 13366230219.5352,
            "max": 23315080560000
        },
        "Population": {
            "min": 5835806,
            "max": 1412360000
        },
        "Territoire": {
            "min": 341500,
            "max": 16376870
        },
        "SurfaceForestiere": {
            "min": 0.0451855944547692,
            "max": 68.6990703076107
        },
        "Croissancepop": {
            "min": -0.459952415807642,
            "max": 2.31648825280279
        },
        "EsperanceVie": {
            "min": 63.785,
            "max": 84.6156097560976
        },
        "PopulationUrbaine": {
            "min": 35.393,
            "max": 92.229
        },
        "TotalReserves": {
            "min": 988316008.036768,
            "max": 3427931394628.85
        }
    };

  const urlParams = new URLSearchParams(window.location.search);
  let countryIndicators = urlParams.get('indicators');
 
  if (!countryIndicators) {
    window.location.href = '../Helicoptere/helicoV3/helicoptere.html';
  } else {
    // Convertir les indicateurs en objet JavaScript
    countryIndicators = JSON.parse(countryIndicators);
  }

  const table = document.createElement('table');
  table.id = 'map';


  // Initialize the map generator with the given parameters
  let mapGenerator = new MapGenerator(250, 250, countryIndicators, etendueIndicator);
      
  // Generate the map
  mapGenerator.generate();

  const map = mapGenerator.exportMap();

  let mapLoader = new Load(map.unitsElementsMatrix, map.lifeDeadZonesMatrix, map.spawnPoints, map.width, map.totems)
  mapLoader.load();

  
  async function drawAndGetPosition() {
    try {
        await drawMap(mapGenerator.unitsElementsMatrix, 20);

        setInterval(() => {
            const canvas = document.getElementById('viewport');
            const position = canvas.getBoundingClientRect();
            console.log(position.top, position.right, position.bottom, position.left);
        }, 2000); // Exécute le bloc de code toutes les 2 secondes (2000 millisecondes)

    } catch (err) {
        console.error("Une erreur s'est produite lors du dessin : ", err);
    }
}

// Appelez la fonction
drawAndGetPosition();

// Créez d'abord votre canevas et votre contexte
let canvas = document.getElementById('mapCanvas');
canvas.width = 50000;
canvas.height = 50000;
let context = canvas.getContext('2d');

// Puis, définissez les coordonnées de votre "fenêtre de vision"
let viewX = 25000 - 5000 / 2; // Centré en X
let viewY = 20000 - 5000 / 2; // Centré en Y
let viewWidth = 5000;
let viewHeight = 5000;

// Vous pouvez maintenant utiliser la méthode contexte.clearRect() pour effacer tout en dehors de votre "fenêtre de vision"
context.clearRect(viewX, viewY, viewWidth, viewHeight);

// Et la méthode contexte.drawImage() pour dessiner uniquement la partie de l'image qui se trouve dans votre "fenêtre de vision"
let image = context.getImageData(viewX, viewY, viewWidth, viewHeight);
let displayCanvas = document.getElementById('displayCanvas'); // Suppose que vous avez un autre canevas dans votre HTML où vous voulez afficher la "fenêtre de vision"
let displayContext = displayCanvas.getContext('2d');
displayContext.putImageData(image, 0, 0);



        /*
        var context = canvas.getContext('2d');

        

        var canvasPosX = 0;
        var canvasPosY = 0;

        var speed = 10; // Vitesse de déplacement

        window.addEventListener('keydown', function(e) {
            switch (e.key) {
                case 'ArrowUp':
                    canvasPosY += speed;
                    break;
                case 'ArrowDown':
                    canvasPosY -= speed;
                    break;
                case 'ArrowLeft':
                    canvasPosX += speed;
                    break;
                case 'ArrowRight':
                    canvasPosX -= speed;
                    break;
            }
            updateCanvasPosition();
        });

        window.addEventListener('mousemove', function(e) {
            var borderRange = 50; // Plage de détection pour le mouvement de la souris

            if (e.clientX < borderRange) {
                canvasPosX += speed;
            } else if (e.clientX > window.innerWidth - borderRange) {
                canvasPosX -= speed;
            }

            if (e.clientY < borderRange) {
                canvasPosY += speed;
            } else if (e.clientY > window.innerHeight - borderRange) {
                canvasPosY -= speed;
            }

            updateCanvasPosition();
        });


  let position = canvas.getBoundingClientRect();

  console.log(position.top, position.right, position.bottom, position.left);*/
  
</script>


</html>